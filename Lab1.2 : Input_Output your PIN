Your GPIO feature have to abstract the Atmega328p (Arduino Uno). The Tensilica LX106 (Esp8266)
is not mandatory for now.
  • Your code allow to control all the digital pin of the target(s), as input or output. More precisely, it
  can:
    o Configure any digital pin as input, or as output


This code allows you to manipulate the PINs of your arduino, either as input or output. In the hard-coded code, first specify which PIN you want to work on, then whether you want to set it to inpout or output. Then copy this code into your MAIN and you can push it onto your arduino. 

MAIN: 

#![no_std]
#![no_main]

use arduino_uno::prelude::*;
use panic_halt as _; // Panique stoppe le programme en cas d'erreur.

#[arduino_uno::entry]
fn main() -> ! {
    let dp = arduino_uno::Peripherals::take().unwrap();

    let mut portb = dp.PORTB.split();
    let mut portc = dp.PORTC.split();
    let mut portd = dp.PORTD.split();

    // 1. Choisir le pin ici : par exemple D13 pour la LED
    let pin_number = "D13";  // Choisir le pin entre "D0" et "D13", ou "A0" à "A5"
    let direction = "output"; // Choisir entre "input" ou "output"
    let output_value = true;  // Si "output", choisir HIGH (true) ou LOW (false)

    // 2. Configurer et manipuler le pin en fonction de la direction (input/output)
    match pin_number {
        // Pins numériques D0 à D13
        "D0" => handle_pin(portd.pd0, &mut portd.ddr, direction, output_value),
        "D1" => handle_pin(portd.pd1, &mut portd.ddr, direction, output_value),
        "D2" => handle_pin(portd.pd2, &mut portd.ddr, direction, output_value),
        "D3" => handle_pin(portd.pd3, &mut portd.ddr, direction, output_value),
        "D4" => handle_pin(portd.pd4, &mut portd.ddr, direction, output_value),
        "D5" => handle_pin(portd.pd5, &mut portd.ddr, direction, output_value),
        "D6" => handle_pin(portd.pd6, &mut portd.ddr, direction, output_value),
        "D7" => handle_pin(portd.pd7, &mut portd.ddr, direction, output_value),
        "D8" => handle_pin(portb.pb0, &mut portb.ddr, direction, output_value),
        "D9" => handle_pin(portb.pb1, &mut portb.ddr, direction, output_value),
        "D10" => handle_pin(portb.pb2, &mut portb.ddr, direction, output_value),
        "D11" => handle_pin(portb.pb3, &mut portb.ddr, direction, output_value),
        "D12" => handle_pin(portb.pb4, &mut portb.ddr, direction, output_value),
        "D13" => handle_pin(portb.pb5, &mut portb.ddr, direction, output_value),

        // Pins analogiques A0 à A5
        "A0" => handle_pin(portc.pc0, &mut portc.ddr, direction, output_value),
        "A1" => handle_pin(portc.pc1, &mut portc.ddr, direction, output_value),
        "A2" => handle_pin(portc.pc2, &mut portc.ddr, direction, output_value),
        "A3" => handle_pin(portc.pc3, &mut portc.ddr, direction, output_value),
        "A4" => handle_pin(portc.pc4, &mut portc.ddr, direction, output_value),
        "A5" => handle_pin(portc.pc5, &mut portc.ddr, direction, output_value),

        _ => {}, // Si le pin n'est pas reconnu
    }

    loop {
        // Boucle infinie
    }
}

// Fonction pour manipuler un pin en fonction de la direction (input/output) et de l'action (écrire/lire)
fn handle_pin<T: PinOps>(
    mut pin: T,
    ddr: &mut T::DDR,
    direction: &str,
    output_value: bool,
) {
    match direction {
        "output" => {
            pin.into_output(ddr);
            // Si c'est un output, on écrit HIGH ou LOW
            if output_value {
                pin.set_high().unwrap();
            } else {
                pin.set_low().unwrap();
            }
        }
        "input" => {
            pin.into_floating_input(ddr);
            // Si c'est un input, on lit l'état du pin
            let state = pin.is_high().unwrap();
            // Si nécessaire, traiter la lecture du pin
            if state {
                // Le pin est HIGH, traitement si nécessaire
            } else {
                // Le pin est LOW, traitement si nécessaire
            }
        }
        _ => {}
    }
}
