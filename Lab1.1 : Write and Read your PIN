Your GPIO feature have to abstract the Atmega328p (Arduino Uno). The Tensilica LX106 (Esp8266)
is not mandatory for now.
  • Your code allow to control all the digital pin of the target(s), as input or output. More precisely, it
  can:
    o Configure any digital pin as input, or as output.
    o Read and write all digital pins.
    o If you want (but is not mandatory), you can abstract the pull-up resistor feature (both
    target support this option) and the pull-down resistor feature (only the Tensilica support
    this option).

This code allows you to manipulate your arduino's PINs, read or write them, set Input or Output. In the hard-coded code, first specify which PIN you want to work on, then whether you want to read or write it, or whether you want to set it to inpout or output. Then copy this code into your MAIN and you can push it onto your arduino. 

MAIN : 
#![no_std]
#![no_main]

use arduino_uno::prelude::*;
use panic_halt as _; // Panique stoppe le programme en cas d'erreur.

#[arduino_uno::entry]
fn main() -> ! {
    let dp = arduino_uno::Peripherals::take().unwrap();

    let mut portb = dp.PORTB.split();
    let mut portc = dp.PORTC.split();
    let mut portd = dp.PORTD.split();

    // 1. Choisir le pin ici : par exemple D13 pour la LED
    let pin_number = "D13";  // Choisir le pin entre "D0" et "D13", ou "A0" à "A5"
    let action = "write";    // Choisir entre "write" ou "read"
    let output_value = true; // Si "write", choisir HIGH (true) ou LOW (false)

    // 2. Configurer et manipuler le pin
    match pin_number {
        // Pins numériques D0 à D13
        "D0" => handle_pin(portd.pd0, &mut portd.ddr, action, output_value),
        "D1" => handle_pin(portd.pd1, &mut portd.ddr, action, output_value),
        "D2" => handle_pin(portd.pd2, &mut portd.ddr, action, output_value),
        "D3" => handle_pin(portd.pd3, &mut portd.ddr, action, output_value),
        "D4" => handle_pin(portd.pd4, &mut portd.ddr, action, output_value),
        "D5" => handle_pin(portd.pd5, &mut portd.ddr, action, output_value),
        "D6" => handle_pin(portd.pd6, &mut portd.ddr, action, output_value),
        "D7" => handle_pin(portd.pd7, &mut portd.ddr, action, output_value),
        "D8" => handle_pin(portb.pb0, &mut portb.ddr, action, output_value),
        "D9" => handle_pin(portb.pb1, &mut portb.ddr, action, output_value),
        "D10" => handle_pin(portb.pb2, &mut portb.ddr, action, output_value),
        "D11" => handle_pin(portb.pb3, &mut portb.ddr, action, output_value),
        "D12" => handle_pin(portb.pb4, &mut portb.ddr, action, output_value),
        "D13" => handle_pin(portb.pb5, &mut portb.ddr, action, output_value),

        // Pins analogiques A0 à A5
        "A0" => handle_pin(portc.pc0, &mut portc.ddr, action, output_value),
        "A1" => handle_pin(portc.pc1, &mut portc.ddr, action, output_value),
        "A2" => handle_pin(portc.pc2, &mut portc.ddr, action, output_value),
        "A3" => handle_pin(portc.pc3, &mut portc.ddr, action, output_value),
        "A4" => handle_pin(portc.pc4, &mut portc.ddr, action, output_value),
        "A5" => handle_pin(portc.pc5, &mut portc.ddr, action, output_value),

        _ => {}, // Si le pin n'est pas reconnu
    }

    loop {
        // Boucle infinie
    }
}

// Fonction pour manipuler un pin en fonction de l'action (write/read)
fn handle_pin<T: PinOps>(
    mut pin: T,
    ddr: &mut T::DDR,
    action: &str,
    output_value: bool,
) {
    match action {
        "write" => {
            pin.into_output(ddr);
            if output_value {
                pin.set_high().unwrap();
            } else {
                pin.set_low().unwrap();
            }
        }
        "read" => {
            pin.into_floating_input(ddr);
            let state = pin.is_high().unwrap();
            // Si nécessaire, gérer la lecture du pin
            if state {
                // Le pin est HIGH, traitement si nécessaire
            } else {
                // Le pin est LOW, traitement si nécessaire
            }
        }
        _ => {}
    }
}
